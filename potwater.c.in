#include <stdio.h>
#include "pico/stdlib.h"
#include "pico/cyw43_arch.h"
#include "lwip/pbuf.h"
#include "lwip/tcp.h"
#include "lwip/priv/tcp_priv.h"
#include "lwip/dns.h"
#include "hardware/timer.h"
#include "hardware/adc.h"
#include "wifi.h"
#include "temp.h"
#include "http_headers.h"

#if !defined(REMOTE_HOST)
#error REMOTE_HOST not defined
#endif

#if !defined(REMOTE_PORT)
#error REMOTE_PORT not defined
#endif

#if !defined(REMOTE_URL)
#define REMOTE_URL /
#endif

#if !defined(AUTH_TOKEN)
#error AUTH_TOKEN not defined
#endif

#define TIMER_DELAY 10000	// In milliseconds

// ============== Config and global variables

#define DHT_PIN 15			// GPIO pin (not board pin)


// Single struct to pass around to callbacks and avoid global variables

struct data_t {
	float onboard_temp;		// PICO internal temp
	struct dht_reading reading;	// DHT sensor
	struct tcp_pcb *pcb;		// TCP client pcb
	ip_addr_t remote_ip;
	char header[300];			// HTTP header
	char payload[30];			// Data string payload
	uint32_t starttime;			// Delay measuring var
};


char ssid[] = "@WIFI_SSID@";
char pass[] = "@WIFI_PASSWORD@";
uint32_t country = CYW43_COUNTRY_WORLDWIDE; //CYW43_COUNTRY_WORLDWIDE;
uint32_t auth = CYW43_AUTH_WPA2_MIXED_PSK; //CYW43_AUTH_WPA2_MIXED_PSK;


// ================= Measurement functions

float read_onboard_temp(void) {
	const float conversionFactor = 3.3f / (1 << 12);
	float adc = (float)adc_read() * conversionFactor;
	float tempC = 27.0f - (adc - 0.706f) / 0.001721f;
	printf("Onboard temp: %.02f\n",tempC);
	return tempC;
}

// ================= TCP callbacks

// ====== This callback is called once a TCP connection is made
err_t tcp_connected_callback(void *arg, struct tcp_pcb *tpcb, err_t err) {
	struct data_t *data = (struct data_t *) arg;
	int payload_len = snprintf(data->payload, sizeof(data->payload), "potwater t=%.1f,h=%.1f",data->reading.temp_celsius,data->reading.humidity);
	//printf("Payload len %d is>%s<\n",payload_len,data->payload);
	int header_len = snprintf(data->header, sizeof(data->header), HTTP_POST_FORMAT(payload_len));
	cyw43_arch_lwip_begin();
	tcp_write(tpcb, data->header, header_len, 0x0);
	tcp_write(tpcb, data->payload, payload_len, 0x0);
	tcp_output(tpcb);
	cyw43_arch_lwip_end();
	printf("connected() called. Data sent\n");
	return ERR_OK;
}

// ====== This callback is called once data is fully sent
err_t tcp_sent_callback(void *arg, struct tcp_pcb *tpcb, u16_t len) {
	puts("sent() called");
	return ERR_OK;
}

// ====== This callback is called with server headers/status received
err_t tcp_recv_callback(void *arg, struct tcp_pcb *tpcb, struct pbuf * p,err_t err) {
	struct data_t *data = (struct data_t *) arg;
	printf("recv() called. ");
	if (p) {
		puts("data");
		tcp_recved(data->pcb,p->tot_len);
		pbuf_free(p);
		return ERR_OK;
	}
	else {
		tcp_sent(data->pcb,NULL);
		tcp_recv(data->pcb,NULL);
		tcp_arg(data->pcb,NULL);

		printf("tcp_close(). ");
		if (tcp_close(tpcb) != ERR_OK) {
			printf("failed, aborting. ");
			tcp_abort(tpcb);
			puts("tcp_abort()ed");
			printf("Total execution time(us): %d\n",time_us_32() - data->starttime);
			return ERR_ABRT;
	    }
		//pbuf_free(p);
	    puts("tcp_closed()");
	}
	//pbuf_free(p);
	printf("Total execution time(us): %d\n",time_us_32() - data->starttime);
	return ERR_OK;
}

// ====== This callback is called once DNS resolves the remote hostname

void dns_found(const char *name, const ip_addr_t *ipaddr, void *arg) {
	struct data_t *data = (struct data_t *) arg;
	data->remote_ip = * ipaddr;
	printf("dns_found() called. Connecting to %s port @REMOTE_PORT@\n",ip4addr_ntoa(ipaddr));
    cyw43_arch_lwip_begin();
    tcp_connect(data->pcb,ipaddr,atoi(REMOTE_PORT),tcp_connected_callback);
    cyw43_arch_lwip_end();
}

// ================= Repeating loop

void upload(struct data_t * data) {
	err_t err;
	printf("Upload() called\n");
	data->pcb = tcp_new();
	tcp_sent(data->pcb, tcp_sent_callback);
	tcp_recv(data->pcb, tcp_recv_callback);
	tcp_arg(data->pcb, data);
/*
	ip4addr_aton("52.44.20.160",&data->remote_ip);
	dns_found(NULL,&data->remote_ip,data);
*/
	printf("DNS resolving host %s dnserver: %s: ",REMOTE_HOST,ip4addr_ntoa(dns_getserver(0)));
	cyw43_arch_lwip_begin();
	err = dns_gethostbyname_addrtype(REMOTE_HOST,&data->remote_ip,dns_found,data,LWIP_DNS_ADDRTYPE_IPV4);
	cyw43_arch_lwip_end();

	if (err == ERR_OK) {
		puts("cached");
		dns_found(NULL,&data->remote_ip,data);
	} else if (err == ERR_INPROGRESS) {
		puts("resolution");
		return;
	} else if (err == ERR_ARG) {
		puts("error");
		return;
	}

/*	ip4addr_aton("@REMOTE_IP@", &remote_ip);
	printf("Connecting to %s port @REMOTE_PORT@\n",ip4addr_ntoa(&remote_ip));
	cyw43_arch_lwip_begin();
	tcp_connect(pcb,&remote_ip,atoi(REMOTE_PORT),tcp_connected_callback);
	cyw43_arch_lwip_end();
        printf("Post done.\n");*/
}


// ================= Main()

int main()
{
    uint8_t addr;
    absolute_time_t nextrun;

	struct data_t * data = malloc(sizeof(struct data_t));

    // Stdio/USB init
    stdio_init_all();
    printf("\n\nInitializing...");

    // DHT init
    gpio_init(DHT_PIN);
   
    // Wifi init
    setup(country, ssid, pass, auth,
                "PlantWater", NULL, NULL, NULL);

    // Onboard temp sensor init
	adc_init();
    adc_set_temp_sensor_enabled(true);
    adc_select_input(4);

    nextrun = make_timeout_time_ms(TIMER_DELAY);

    printf("Initialization complete. Sleeping\n");

	// Big loop
    while (true) {
	    sleep_until(nextrun);
	    nextrun = make_timeout_time_ms(TIMER_DELAY);
		data->starttime = time_us_32();
		puts("-------------------");
		puts("Reading onboard_temp");
	    data->onboard_temp = read_onboard_temp();
		puts("Reading DHT11");
	    read_temp(&data->reading,DHT_PIN);
	    if (data->reading.temp_celsius == -111) {
                puts("DHT Bad Data\n");
            }
		else {
			printf("Humidity = %.1f%%, Temperature = %.1fC\n",
					data->reading.humidity, data->reading.temp_celsius);
	    }
	    upload(data);
		//printf("tcp_listen_pcbs: %d",sizeof(tcp_listen_pcbs));
		tcp_debug_print_pcbs();
		printf("Total time in us in loop: %d\n",time_us_32() - data->starttime);
    }

}


